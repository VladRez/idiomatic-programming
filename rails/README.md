
# HTTP requests

When a web browser communicate with a web server:

1. The browser sends an HTTP request to the web server.
    + URL is translated to a *request* message.
    + URL: `protocol://hostname:port/path-to-file`
        + `protocol` - HTTP, FTP, ...
        + `hostname` - DNS domain name (www.google.com) or ip address (127.0.0.1) 
        + `port` - TCP port the server is listening for requests
        + `path-to-file` - name and location of the requested resource

HTTP request message composed of:

+ **Request Message header**
    + Request Line
        + *request-method-name* HTTP protocol defines a set of request methods
            + `GET` - get a web resource from the server
            + `POST` - post data up to the web server
            + `PUT` - store data on the server
            + `DELETE` - delete data from the server
            + `TRACE` - return a diagnostic trace of the actions it takes  
            + `HEAD` - get the header that a `GET` request would have obtained
            + `OPTIONS` - return the list of request methods a server supports
        + *request-URI* - specifies the resource requested
        + *HTTP-version* - HTTP version
            + `HTTP/1.0`
            + `HTTP/1.1`    
    + Request Headers
        + name:value pairs
        + `request-header-name: request-header-value1, request-header-value2, ...`
+ **A blank line to separate request message header and request message body**
+ **Optional Request Message body**

HTTP request 
```sh
GET /path/index.html HTTP/1.1  <- Request line | < Request Message Header
Host: www.website.com   | <- Request Headers   | 
User-Agent: Chrome      |
                        | <- Blank line
bookId=21345&title=ruby | <- Request Message Body
```

2. The web server attempts to find the appropriate path/file.

3. The web server sends the response back 


HTTP response message composed of:

+ **Response Message:**
    + Response Message Header
        + Status Line
            + *HTTP-version*
                + HTTP/1.0
                + HTTP/1.1
            + *status-code* - 3 digit code generated by the server to reflect the outcome of the request
                + 200
                + 404
                + 403
                + 500
            + *reason-phrase* - gives a short explanation to the status code
                + `OK`
                + `Not Found`
                + `Forbidden`
                + `Internal Server Error`
        + **Response Header**
            + name:value pairs
            + `response-header-name: response-header-value1, response-header-value2, ...`
+ **Separated by a blank line**
+ **Optional Response Message Body**

```sh
HTTP/1.1 200 OK                     | <- Status Line        | <- Response Message Header
Date: Mon, 12 JUN 2012 15:17:20 PST | <- Response Headers   | 
Server: Apache                      |                       |
Content-Type: text/html             |                       |
                                    | <- blank separator
<html>...</html>                    | <- Response Message Body
```


# Rails MVC App

1. The browser issues a request (an incoming URL, e.g. `website.com/users`) to the web server 
    + HTTP request `GET`, `POST`, `PATCH`, `DELETE`
2. The web server receives the request and then passes it to the `Router`
    + configured in `config/routes.rb`
3. The router sends the request to a specific action in the `Controller`
    + The `Controller` is simply a ruby class and the `action` is a ruby method that handles the request.
    + Example of mapping a `GET` request to a controller action: `get "users" => "users#index"`
    + To create a controller `rails g controller [controller name]`
        + `rails g controller Users`
        + creates a new controller file in `app/controllers/users_controller.rb`
        + controller name is plural by convention
        + `UsersController` class inherits from a base class of all controllers called `ApplicationController`


```ruby
class UsersController < ApplicationController
    def index
        # ...
    end
end
```
4. `Controller` interacts with a `Model` class.
    + `Model` represents a real world concept, such as a user on a website. 
        + provides an easier way to be read, update and create entries from a database table.
        + Runs application logic
        + Created with `rails g model [model name]`
            + `rails g model User username:string email:string`
            + Generates a database schema in `db/migrate/`

```ruby
class CreateUsers < ActiveRecord::Migration
    def change
        create_table :users do |t|
            t.string :username #adding a column to the table
            t.string :email

            t.timestamps
        end
    end
end
```
+ Run `rails`/`rake db:migrate` to create or update the table schema.
+ The `User` Model will automatically gives us access to the `Users` table

```ruby
    class User < ActiveRecord
        # ...
    end
```
    
+ Each row act as an object

|id|username|email|
|--|--------|-----|
|1|oddball|ob9@yahoo.net|
|2|wizard|wzd2@gmail.com|
|3|magma|mma14@live.io|
   
     
5. The `Controller` sends data to the `View` 
    + located in `app/view/users/index.html.erb`
    + `View` renders html with `*.html.erb` template.
        + `<% ruby_method %>` tags executes ruby code without a return value.
        + `<%= ruby_method %>` tags executes ruby code and returns a value.
6. Send result back to the browser as a response.

The controller acts as an intermediary between `Model` and `View`

# Active Records

The `rake` utility automates common tasks in Rails. 
+ `rails - T` / `rake -T` will show available tasks.

## Domain Modeling

### Models

A model represents an entity in a Rails application used to Create, Read, Update and Delete (CRUD) entries in a database.
+ A model is a Ruby class
    + Model name is singular by convention
```ruby
class Book < ApplicationRecord
    #...
end

# Which inherits from
class ApplicationRecord < ActiveRecord::Base
    self.abstract_class = true
end
```
+ By convention the table name is **plural** because it contains many records/rows.

The `Book` Model gives us access to the `books` table, effectively wrapping the table for CRUD access.
+ The class attributes match the column names.
___
**books** table

|id|title|author|
|--|-----|------|
|1 |ruby|Yukihiro Matsumoto|
|2 |javascript|Brendan Eich|
|3 |python|Guido van Rossum|
___

We create a `books` database to store all our books and a `Book` model to access the table.

+  Creating a Model `rails generate [singular model name]`
    

`db/migrate/{timestamp}_create_{model}.rb` creates a migration file

```ruby
class CreateBooks < ActiveRecord::Migration[5.2]
    # Rails will call 'change' method to make database scheme changes
        # This will properly convert field types to match database in use (mysql, postgres, sqlite, etc...)
    def change
        create_table :books do |t|
            t.string :title
            t.timestamps
        end
    end
end
```

`app/models/{model name}.rb` the model itself 

```ruby
class Book < ApplicationRecord
    # implicit access to table fields
    # attr_accessor :title
end
# which in turn inherits from
class ApplicationRecord < ActiveRecord::Base
    # inherits methods such as count, find, find_by
end
```

#### Migrations

Generating a model creates a migration file, this file that acts as a audit trail for changes in the database schema. By following certain conventions Rails will automatically generate code:

+ `rails generate model book title:string pages:integer`

```ruby
class CreateBooks < ActiveRecord::Migration[5.2]
    def change
        create_table :books do |t|
            # type,    column
            t.string :title
            t.integer :pages
            t.timestamps
        end
    end
end
```

Next we run the migrations.

+ `rails db:migrate` run the migration and create the tables in the database.
+ `rails db:migrate:status` show the status of the migration

If we wanted to update the schema, for example add a column:
+ `rails g migration AddFieldsToBooks author:string description:text`
    
Rails will generate the migration 

```ruby
class AddFieldsToBooks < ActiveREcord::Migration[5.2]
    def change
        #           table   column  type
        add_column :books, :author, :string
        add_column :books, :description, :text
    end
end
```
+ `rails db:migrate` to apply changes
    + `rails c` use rails console to test changes

### Rails Console

`rails c` loads up a rails console environment that lets you interact with the models without a web browser. 

If we declare a model `Book` rails will show it's connection to the database by displaying the table fields as class attributes. This is because the model inherits from `ActiveRecord::BASE`

+ `book = Book.new()` instantiates an empty record object
    + `book.title = "ruby"` assign a value to an object's attribute 
    + `book.save` save the object as a record to the database
        + sql: `INSERT INTO "books" ("title") VALUES (?) ["title", "ruby"]`
+ `book = Book.create(title: "")` will instantiates and save a new record
    + sql: `INSERT INTO "books" ("title") VALUES (?) ["title", "ruby"]`
+ `Book.count` - returns the number of entries
    + sql `SELECT count(*) FROM "books"`
+ `Book.all` - returns an array of entries as objects
    + sql: `SELECT "books".* FROM "books"`
+ `Book.first` - returns the first entry in the table
    + sql: `SELECT "books".* FROM "books" ORDER BY "books"."id" DESC LIMIT 1`
+ `Book.find_by(id: 1)` where `1` is the key, search for record by id.
    + sql: `SELECT "books".* FROM "books" WHERE "books"."id" = ? LIMIT 1 [["id"], 1]`
    + `ActiveRecord::RecordNotFound:` error will occur when passed a key that doesn't exist.
+ `Book.find_by(title: "ruby")` find by hash `attribute: value`
    + sql: `SELECT "books" FROM "books"."title" = 'ruby' LIMIT 1`
    + returns `nil` if a record is not found
+ `Book.update(title: "js")` update multiple fields/attributes with a hash
    + sql: `UPDATE "books" SET "title" = ? WHERE "books"."id" = 3 [["title, "js"]]`
+ `Books.find(1).destroy` to delte from the table
    + sql: `DELETE FROM "books" WHERE "books"."id" = ? [["id", 4]]`


Since models are classes, methods can be written to help individual instances.

```ruby
class Book < ApplicationRecord
    def blank_book?
        self.pages == 0
    end
end

```
### Helpers

In the context of Rails console we have a `helper` object to provide helpful methods such as formatting, text, numbers and dates for the views. This `helper` object is implicitly available in the views.

More helpers can be created in `app/helpers/books_helper.rb`

```ruby
module BooksHelper
    def format_title(title)
        # content_tag: helper method to generate html
        content_tag(:h1, title.upcase)
    end
end
```
### Associations

Associations are methods that generate code to connects models together. 
Useful for abstracting away SQL

Although there are many association types the common ones are:

+ `belongs_to` - matches a model's `foreign key` to a target model's `primary key`
    `...where users.id = ?`
+ `has_many` - matches a model's `primary key` to a target model's `foreign key`
    `...where users.foreign_key_name = ?`
    + `has_many` `through:`  using other associations when there's no direct `foreign key` available
+ `has_one` - same as `has_many` but limits the result by 1

format: association_type(:method_name, options_hash)

```ruby
#:name of method will be the name of the method used to invoke active records
has_many(:name_of_association_1, {
    primary_key: :id, # primary key column
    foreign_key: :f_id, # foreign key column
    class_name: :Model_name # Name of model class
})

belongs_to(:name_of_association_2, {
    primary_key: :id, # primary key column
    foreign_key: :f_id, # foreign key column
    class_name: :Model_name # Name of model class
})

has_many(:name_of_association_3, {
    through: :name_of_association_2, # association name
    source: :other_association_1
})
# Through association automatically creates inner joins
```

# Routing

Routes connect HTTP requests to controller actions.

`config/routes.rb`

Route
+ `get("/path/:id",{to: "controller#action", as: "method"})`
    + `get()` - http method
    + `/path/` - path to `controller#action`
        + `:id` - dynamic variable that will be available as a parameter
    + `to: "controller#action"` - code to be executed
    + `as:  "method"` - method that directs to path
        + `as: book` - > `book_path(1)` - > `/books/1` 

```ruby
Rails.application.routes.draw do
    # routes a GET request to the index action in the books controller 
        #books refers to the controller file not class
    get("/books", {to: "books#index", as: 'books'})
    # routes a GET to the show action, explicit id
    #get "books/1" => "books#show"
    get("/books/:id", {to: "books#show", as: 'book'})
    #or
    # get "books/show"
    #or
    # books = {books: "books#index"}
    # get(books)
end

```
### Linking Routes

 URL links are automatically captured in a nested hash structure called `params` and is accessible within any action.

`http://www.website.com/books/1` is functionally the same as `Book.find(1)` or `Book.find_by(id: 1)` because the URI is captured as `{id: 1}`. 

```ruby
class BooksController < ApplicationController
    def index
        @books = Book.all
    end

    def show
        # `localhost:3000/books/1`
            # Gives us a generic way to find any id
        @book = Book.find(params[:id])
    end
end
```

URL PATH - > ROUTES - > CONTROLLER -> ACTION

|HTTP method|Path|Controller Action|Description|
|-----------|----|-----------------|-----------|
|GET|/books|books#index|Present a list of books|
|GET|/books/new|books#new|Present HTML form for creating a book|
|POST|/books|books#create|Create a new book|
|GET|/books/:id|books#show|Present a specific book|
|GET|/books/:id/edit|books#edit|Present HTML form for editing a book|
|PATCH/PUT|/books/:id|books#update|Update a specific book|
|DELETE|/books/:id|books#destroy|Delete a specific book|


## URI Paths

Display all available routes:
+ In a web broser
    + `localhost:3000/rails/info/routes` 
+ In Terminal: `Rails` / `Rake` `routes`   
```
> rails routes
Prefix Verb URI Pattern         Controller#Action
books GET /books(.:format)    books#index
      GET /books/:id          books#show
```


Creating dynamic links between routes:

+ `link_to(friendly_name, route)` - rails method to create a hyperlinks to a route
    + In views `<%= link_to("All Books","/books") %>` same as `<a href="/books">All Books</a>` 

```html
<ul>
    <% @books.each do |book| %>
        <li><%= link_to(book.name, "books/#{book.id}") %></li>
    <% end %>
</ul>
```


Rails is able to generate the url based on the routes:
```
> rails c
app.books_path
=> "/books"
app.books_url
=> "http://wwwexample.com/books"
```

Both are interchangeable and link to a route
+ **_url**
    + generally used in controllers
    
+ **_path**
    + generally used in views
    + `<%= link_to "All Books", books_url %>`

However not all actions have route names and have to be explicitly created

```
> rails routes
Prefix Verb URI Pattern         Controller#Action
books GET /books(.:format)    books#index
      GET /books/:id          books#show
```
Add a rout to an individual book page:

`config/routes.rb`
```ruby
Rails.application.routes.draw do
    #root "books#index" redirect root page to index action in books controller
    get "books" => "books#index"
    get({"books/:id" => {to: "books#show", as: "book"}}) #<
end
```

```
> rails routes
Prefix Verb URI Pattern         Controller#Action
books GET /books(.:format)    books#index
book  GET /books/:id          books#show
```

Since the route now has a placeholder `:id` we need to supply the `book` id to a helper method as a parameter

rails console
```
>> app.book_path(1)
=> "/books/1"
>> app.book_url(1)
=> "http://www.example.com/books/1"
>> b = Book.first
>> app.boo,_path(b.id)
=> "/books/1"
>> app.event_path(b)
=> "events/1"
```

Views: `app/views/books/index.html.erb`

```html
<ul>
    <% @books.each do |b| %>
        <li><%= link_to(b.name, book_path(b.id)) %></li>
        <!--
           In this Context:
            
            Rails convention to shorthand b.id
            <%= link_to(b.name, book_path(b)) %>

            Rails convention to shorthand book_path(b.id)
            <%= link_to(b.name, b) %>
        -->
    <% end %>
</ul>
```

|Route Name|HTTP|URL pattern|controller#action|Helper Method|Generates|
|-----------|----|-----------|-----------------|-------------|---------|
|books|GET|/books(.:format)|books#index|books_url|http://www.example.com/books|
|books|GET|/books(.:format)|books#index|books_path|/books|
|book|GET|/book/:id(.:format)|book#show|book_url(1)|http://www.example.com/book/1|
|book|GET|/book/:id(.:format)|book#show|book_path(1)|/book/1|

<!-- ## Forms

Creating and Updating records using forms

+ `form_for` - generates html for forms and sends the form data in a `params` hash to the controller


hyperlink -> route to /book/1/edit -> book(controller)#edit(action) -> render view -->


`config/routes.rb`

```ruby
Rails.application.routes.draw do
root({to: 'books#index'})
  get('/books/new', {to: 'books#new', as: 'new_book'})
  get('/books', {to: 'books#index', as: 'books'})
  get('/books/:id/show', {to: 'books#show', as: 'show_book'})
  get('/books/:id/edit', {to: 'books#edit', as: 'edit_book'})
  patch('/books/:id/update', {to: 'books#update', as: 'update_book'})
  post('/books/create', {to: 'books#create', as: 'create_book'})
  delete('/books/:id/destroy', {to: 'books#destroy', as: 'destroy_book'})
end
```

`rails routes`

```
      Prefix Verb   URI Pattern                    Controller#Action
        root GET    /                              books#index
    new_book GET    /books/new(.:format)           books#new
       books GET    /books(.:format)               books#index
   show_book GET    /books/:id/show(.:format)      books#show
   edit_book GET    /books/:id/edit(.:format)      books#edit
 update_book PATCH  /books/:id/update(.:format)    books#update
 create_book POST   /books/create(.:format)        books#create
destroy_book DELETE /books/:id/destroy(.:format)   books#destroy
```

Accessing the edit path for example:

In `rails c`
```
>> app.edit_book_path(1)
=> 'book/1/edit/`
```

 Also renders a form in `edit.html.erb` view. A form needs to bind to some object and the `params` hash will provide data to `books#edit` controller#action using the `:id` that's specified in the router to create that object. 

`params` hash:

```
{"id"=>"1"}
```

`books#edit`

```ruby
    def edit
        @book = Book.find_by(id: params[:id])
    end
```

`edit.html.erb`
```html
<h1>Editing <%= @book.title %></h1>

<%= form_for(@book, {as: :form_data, url: update_book_path(@book.id), method: :patch}) do |f| %>
   <%=  f.label("Book Title") %>
    <%= f.text_field(:title) %>

   <%=  f.label("Number of Pages") %>
    <%= f.text_field(:pages) %>

    <%= f.submit %>
<% end %>

<%= link_to("ALL BOOKS", books_path) %>
```

Submitting the form will pass the information in the `params` hash to the mapped controller `books#update`.

```
{"utf8"=>"âœ“",
 "_method"=>"patch",
 "authenticity_token"=>"+aahApa9ivhiX8R094gx19OsOTqHOy7opNTOAaFpgI6C8d==",
 "form_data"=>{"title"=>"Java", "pages"=>"100"},
 "commit"=>"Update Record",
 "id"=>"1"}
```

`books_controller.rb`

Since form data can be compromised and malicious data can be sent we need to whitelist keys in the `params` hash and permit only certain attributes intended to be assigned from a form.

instead of 
+ `@book.update(params[:form_data])` - mass assignment
+ `@book.update(title: params[:form_data][:title], pages: params[:form_data][:pages].to_i)`

It's better to create a utility method using the `require` method to require a key to exist in the `params` hash and exclusively permit the form fields with `permit`
```ruby
class BookController < ApplicationController
    def edit
        @book = Book.find_by(id: params[:id])
    end

    def update
        @book = Book.find_by(id: params[:id])
        @book.update(book_params)
        # run the show method
        redirect_to  book_show_url(@book.id)
    end

    private

    def book_params
         params.require(:form_data).permit(:title, :pages)
    end
end
```

Options to show the results of an action:
+ `render` - use the view template to show the response of an action.
    + Won't work with patch requests as re-loading the page will re-run patch method.
+ `redirect_to` - run an action with a path


This is a tedious workflow and rails provides an easier way of doing this.

Given an entity like a book it common to:
+ Create a record
+ List all records
+ Display a record
+ Edit a record
+ Delete a record

In rails these are called *resources* and can be simplified down to:

```ruby
Rails.application.routes.draw do
    resources :books
end
```

Resulting automatically creating routes:
```
   Prefix Verb   URI Pattern                   Controller#Action
    books GET    /books(.:format)              books#index 
          POST   /books(.:format)              books#create
 new_book GET    /books/new(.:format)          books#new
edit_book GET    /books/:id/edit(.:format)     books#edit
     book GET    /books/:id(.:format)          books#show
          PATCH  /books/:id(.:format)          books#update
          PUT    /books/:id(.:format)          books#update
          DELETE /books/:id(.:format)          books#destroy
```

Then just update the form to match the new route
`edit.html.erb`
```html
<h1>Editing <%= @book.title %></h1>

<%= form_for(@book, {as: :form_data, url: book_path(@book.id), method: :patch}) do |f| %>
   <%=  f.label("Book Title") %>
    <%= f.text_field(:title) %>

   <%=  f.label("Number of Pages") %>
    <%= f.text_field(:pages) %>

    <%= f.submit %>
<% end %>

<%= link_to("ALL BOOKS", books_path) %>
```






