
# HTTP requests

When a web browser communicate with a web server:

1. The browser sends an HTTP request to the web server.
    + URL is translated to a *request* message.
    + URL: `protocol://hostname:port/path-to-file`
        + `protocol` - HTTP, FTP, ...
        + `hostname` - DNS domain name (www.google.com) or ip address (127.0.0.1) 
        + `port` - TCP port the server is listening for requests
        + `path-to-file` - name and location of the requested resource

HTTP request message composed of:

+ **Request Message header**
    + Request Line
        + *request-method-name* HTTP protocol defines a set of request methods
            + `GET` - get a web resource from the server
            + `POST` - post data up to the web server
            + `PUT` - store data on the server
            + `DELETE` - delete data from the server
            + `TRACE` - return a diagnostic trace of the actions it takes  
            + `HEAD` - get the header that a `GET` request would have obtained
            + `OPTIONS` - return the list of request methods a server supports
        + *request-URI* - specifies the resource requested
        + *HTTP-version* - HTTP version
            + `HTTP/1.0`
            + `HTTP/1.1`    
    + Request Headers
        + name:value pairs
        + `request-header-name: request-header-value1, request-header-value2, ...`
+ **A blank line to separate request message header and request message body**
+ **Optional Request Message body**

HTTP request 
```sh
GET /path/index.html HTTP/1.1  <- Request line | < Request Message Header
Host: www.website.com   | <- Request Headers   | 
User-Agent: Chrome      |
                        | <- Blank line
bookId=21345&title=ruby | <- Request Message Body
```

2. The web server attempts to find the appropriate path/file.

3. The web server sends the response back 


HTTP response message composed of:

+ **Response Message:**
    + Response Message Header
        + Status Line
            + *HTTP-version*
                + HTTP/1.0
                + HTTP/1.1
            + *status-code* - 3 digit code generated by the server to reflect the outcome of the request
                + 200
                + 404
                + 403
                + 500
            + *reason-phrase* - gives a short explanation to the status code
                + `OK`
                + `Not Found`
                + `Forbidden`
                + `Internal Server Error`
        + **Response Header**
            + name:value pairs
            + `response-header-name: response-header-value1, response-header-value2, ...`
+ **Separated by a blank line**
+ **Optional Response Message Body**

```sh
HTTP/1.1 200 OK                     | <- Status Line        | <- Response Message Header
Date: Mon, 12 JUN 2012 15:17:20 PST | <- Response Headers   | 
Server: Apache                      |                       |
Content-Type: text/html             |                       |
                                    | <- blank separator
<html>...</html>                    | <- Response Message Body
```


# Rails MVC App

1. The browser issues a request (an incoming URL, e.g. `website.com/users`) to the web server 
    + HTTP request `GET`, `POST`, `PATCH`, `DELETE`
2. The web server receives the request and then passes it to the `Router`
    + configured in in `config/routes.rb`
3. The router sends the request to a specific action in the `Controller`
    + The `Controller` is simply a ruby class and the `action` is a ruby method that handles the request.
    + Example of mapping a `GET` request to a controller action: `get "users" => "users#index"`
    + To create a controller `rails g controller [controller name]`
        + `rails g controller Users`
        + creates a new controller file in `app/controllers/users_controller.rb`
        + controller name is plural by convention
        + `UsersController` class inherits from a base class of all controllers called `ApplicationController`


```ruby
class UsersController < ApplicationController
    def index
        # ...
    end
end
```
4. `Controller` interacts with a `Model` class.
    + `Model` represents a real world concept, such as a user on a website. 
        + provides an easier way to be read, update and create entries from a database table.
        + Runs application logic
        + Created with `rails g model [model name]`
            + `rails g model User username:string email:string`
            + Generates a database schema in `db/migrate/`

```ruby
class CreateUsers < ActiveRecord::Migration
    def change
        create_table :users do |t|
            t.string :username #adding a column to the table
            t.string :email

            t.timestamps
        end
    end
end
```
+ Run `rails`/`rake db:migrate` to create or update the table schema.
+ The `User` Model will automatically gives us access to the `Users` table

```ruby
    class User < ActiveRecord
        # ...
    end
```
    
+ Each row act as an object

|id|username|email|
|--|--------|-----|
|1|oddball|ob9@yahoo.net|
|2|wizard|wzd2@gmail.com|
|3|magma|mma14@live.io|
   
     
5. The `Controller` sends data to the `View` 
    + located in `app/view/users/index.html.erb`
    + `View` renders html with `*.html.erb` template.
        + `<% ruby_method %>` tags executes ruby code without a return value.
        + `<%= ruby_method %>` tags executes ruby code and returns a value.
6. Send result back to the browser as a response.

The controller acts as an intermediary between `Model` and `View`

# Active Records

The `rake` utility automates common tasks in Rails. 
+ `rails - T` / `rake -T` will show available tasks.

## Domain Modeling

### Models

A model represents an entity in a Rails application used to Create, Read, Update and Delete (CRUD) entries in a database.
+ A model is a Ruby class
    + Model name is singular by convention
```ruby
class Book < ApplicationRecord
    #...
end

# Which inherits from
class ApplicationRecord < ActiveRecord::Base
    self.abstract_class = true
end
```
+ By convention the table name is **plural** because it contains many records/rows.

The `Book` Model gives us access to the `books` table, effectively wrapping the table to for CRUD access.
+ The class attributes match the column names.
___
**books** table

|id|title|author|
|--|-----|------|
|1 |ruby|Yukihiro Matsumoto|
|2 |javascript|Brendan Eich|
|3 |python|Guido van Rossum|
___

We create a `books` database to store all our books and a `book` model to access the table.

+  Creating a Model `rails generate [singular model name]`
    

`db/migrate/{timestamp}_create_{model}.rb` creates a migration file

```ruby
class CreateBooks < ActiveRecord::Migration[5.2]
    # Rails will call this method to make database scheme changes
        # This will properly convert field types to match database in use (mysql, postgres, sqlite, etc...)
    def change
        create_table :books do |t|
            t.string :title
            t.timestamps
        end
    end
end
```

`app/models/{model name}.rb` the model itself 

```ruby
class Book < ApplicationRecord
    # implicit access to table fields
    # attr_accessor :title
end
# which in turn inherits from
class ApplicationRecord < ActiveRecord::Base
    # inherits methods such as count, find, find_by
end
```

#### Migrations

Generating an model creates a migration file, this file that acts as a audit trail for changes in the database schema. By following certain conventions Rails will automatically generate code.

+ `rails generate model book title:string pages:integer`

```ruby
class CreateBooks < ActiveRecord::Migration[5.2]
    def change
        create_table :books do |t|
            # type,    column
            t.string :title
            t.integer :pages
            t.timestamps
        end
    end
end
```

Next we run the migrations.

+ `rails db:migrate` run the migration and create the tables in the database.
+ `rails db:migrate:status` show the status of the migration

If we wanted to update the schema, for example add a column:
+ `rails g migration AddFieldsToBooks author:string description:text`
    
Rails will generate the migration 

```ruby
class AddFieldsToBooks < ActiveREcord::Migration[5.2]
    def change
        #           table   column  type
        add_column :books, :author, :string
        add_column :books, :description, :text
    end
end
```
+ `rails db:migrate` to apply changes
    + `rails c` use rails console to test changes

### Rails Console

`rails c` loads up a rails console environment that lets you interact with the models without a web browser. 

If we declare a model `Book` rails will show it's connection to the database by displaying the table fields as class attributes. This is because the model inherits from `ActiveRecord::BASE`

+ `book = Book.new()` instantiates an empty record object
    + `book.title = "ruby"` assign a value to an object's attribute 
    + `book.save` save the object as a record to the database
        + sql: `INSERT INTO "books" ("title") VALUES (?) ["title", "ruby"]`
+ `book = Book.create(title: "")` will instantiates and save a new record
    + sql: `INSERT INTO "books" ("title") VALUES (?) ["title", "ruby"]`
+ `Book.count` - returns the number of entries
    + sql `SELECT count(*) FROM "books"`
+ `Book.all` - returns an array of entries as objects
    + sql: `SELECT "books".* FROM "books"`
+ `Book.first` - returns the first entry in the table
    + sql: `SELECT "books".* FROM "books" ORDER BY "books"."id" DESC LIMIT 1`
+ `Book.find_by(1)` where `1` is the key, search for record by id.
    + sql: `SELECT "books".* FROM "books" WHERE "books"."id" = ? LIMIT 1 [["id"], 1]`
    + `ActiveRecord::RecordNotFound:` error will occur when passed a key that doesn't exist.
+ `Book.find_by(title: "ruby")` find by hash `attribute: value`
    + sql: `SELECT "books" FROM "books"."title" = 'ruby' LIMIT 1`
    + returns `nil` if a record is not found
+ `Book.update(title: "js")` update multiple fields/attributes with a hash
    + sql: `UPDATE "books" SET "title" = ? WHERE "books"."id" = 3 [["title, "js"]]`
+ `Books.find(1).destroy` to delte from the table
    + sql: `DELETE FROM "books" WHERE "books"."id" = ? [["id", 4]]`


Since models are classes methods can be written to help indivual instances.

```ruby
class Book < ApplicationRecord
    def blank_book?
        self.pages == 0
    end
end

```
### Helpers

In the context of Rails console we have a `helper` object to provide helpful methods such as formatting, text, numbers and dates for the views. This `helper` object is implicitly available in the views.

More helpers can be create included in `app/helpers/books_helper.rb`

```ruby
module BooksHelper
    def format_title(title)
        # content_tag: helper method to generate html
        content_tag(:h1, title.upcase)
    end
end
```

## Routing

Routes connect HTTP requests to controller actions.

`config/routes.rb`
```ruby
Rails.application.routes.draw do
    # routes a GET request to the index action in the books controller 
    get "books" => "books#index"
    # routes a GET to the show action, explicit id
    get "books/1" => "books#show"

    get "books/:id" => "books#show"
    #or
    # get "books/show"
    #or
    # books = {books: "books#index"}
    # get(books)
end

```

When we point our web browser to a web resource this gets sent to 

To have access to books or a book we must define the actions in the controllers:

```ruby
class BooksController < ApplicationController
    def index
        @books = Book.all
    end

    def show
        @book = Book.find(1)
    end
end
```


|HTTP method|Path|Controller Action|Description|
|-----------|----|-----------------|-----------|
|GET|/books|books#index|Present a list of books|
|GET|/books/new|books#new|Present HTML form for creating a book|
|POST|/books|books#create|Create a new book|
|GET|/books/:id|books#show|Present a specific book|
|GET|/books/:id/edit|books#edit|Present HTML form for editing a book|
|PATCH/PUT|/books/:id|books#update|Update a specific book|
|DELETE|/books/:id|books#destroy|Delete a specific book|